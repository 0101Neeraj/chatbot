inside the app folder

__init__.py

from flask import Flask
from flask_cors import CORS
from .config import load_config
from .db import init_db


def create_app() -> Flask:
	app = Flask(__name__)
	CORS(app)
	load_config(app)
	init_db(app)

	from .routes import api_bp  # noqa: E402
	app.register_blueprint(api_bp)

	return app


config.py

import os
from dotenv import load_dotenv


def load_config(app):
	load_dotenv(override=False)
	app.config.setdefault("SQLALCHEMY_DATABASE_URI", os.getenv("DATABASE_URL", "postgresql+psycopg2://postgres:postgres@localhost:5432/sampledb"))
	app.config.setdefault("SQLALCHEMY_ECHO", False)
	app.config.setdefault("JSON_SORT_KEYS", False)

db.py

from __future__ import annotations

from typing import Dict, List

from flask import Flask
from sqlalchemy import create_engine, inspect, text
from sqlalchemy.engine import Engine
from sqlalchemy.orm import scoped_session, sessionmaker


engine: Engine | None = None
SessionLocal = scoped_session(sessionmaker(autocommit=False, autoflush=False))


def init_db(app: Flask) -> None:
	global engine  # noqa: PLW0603
	engine = create_engine(app.config["SQLALCHEMY_DATABASE_URI"], pool_pre_ping=True)
	SessionLocal.configure(bind=engine)


def get_db_session():
	return SessionLocal()


def get_db_status() -> Dict[str, object]:
	if engine is None:
		return {"status": "not_initialized"}
	inspector = inspect(engine)
	try:
		with engine.connect() as conn:
			conn.execute(text("SELECT 1"))
		schema = inspector.default_schema_name or "public"
		tables: List[str] = inspector.get_table_names(schema=schema)
		name = engine.url.database
		return {
			"name": name,
			"schema": schema,
			"tables": tables,
			"status": "connected",
		}
	except Exception as exc:  # pragma: no cover - connectivity issue
		return {"status": "error", "error": str(exc)}


models.py

from __future__ import annotations

from datetime import date

from sqlalchemy import CheckConstraint, Date, Integer, String
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column


class Base(DeclarativeBase):
	pass


class Task(Base):
	__tablename__ = "tasks"

	id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
	project_name: Mapped[str] = mapped_column(String(120), index=True, nullable=False)
	task_name: Mapped[str] = mapped_column(String(200), nullable=False)
	user_name: Mapped[str] = mapped_column(String(80), index=True, nullable=False)
	start_date: Mapped[date] = mapped_column(Date, index=True, nullable=False)
	days_required: Mapped[int] = mapped_column(Integer, nullable=False)
	end_date: Mapped[date] = mapped_column(Date, index=True, nullable=False)
	progress: Mapped[int] = mapped_column(Integer, nullable=False, default=0)

	__table_args__ = (
		CheckConstraint("progress >= 0 AND progress <= 100", name="ck_progress_range"),
	)

routes.py

from __future__ import annotations

from datetime import date
from typing import Dict, Iterable, List, Tuple

import pandas as pd
from flask import Blueprint, jsonify, request
from sqlalchemy import asc, desc, extract, func, select

from .db import get_db_session, get_db_status
from .models import Base, Task

api_bp = Blueprint("api", __name__)


@api_bp.before_app_first_request
def create_tables_if_needed():
	session = get_db_session()
	try:
		engine = session.get_bind()
		Base.metadata.create_all(bind=engine)
	finally:
		session.close()


@api_bp.get("/database-check")
def database_check():
	return jsonify(get_db_status())


@api_bp.post("/api/upload-xlsx")
def upload_xlsx():
	if "file" not in request.files:
		return jsonify({"error": "missing file"}), 400
	file = request.files["file"]
	if file.filename == "":
		return jsonify({"error": "empty filename"}), 400

	try:
		df = pd.read_excel(file, engine="openpyxl")
		# Expected columns mapping
		column_map = {
			"Project Name": "project_name",
			"Task Name": "task_name",
			"User": "user_name",
			"Start Date": "start_date",
			"Days Required": "days_required",
			"End Date": "end_date",
			"Progress": "progress",
		}
		missing = [c for c in column_map if c not in df.columns]
		if missing:
			return jsonify({"error": f"missing columns: {missing}"}), 400

		records: List[Task] = []
		for _, row in df.iterrows():
			records.append(
				Task(
					project_name=str(row["Project Name"]).strip(),
					task_name=str(row["Task Name"]).strip(),
					user_name=str(row["User"]).strip(),
					start_date=pd.to_datetime(row["Start Date"]).date(),
					days_required=int(row["Days Required"]),
					end_date=pd.to_datetime(row["End Date"]).date(),
					progress=int(row["Progress"]),
				),
			)

		session = get_db_session()
		try:
			session.add_all(records)
			session.commit()
		finally:
			session.close()
		return jsonify({"inserted": len(records)})
	except Exception as exc:
		return jsonify({"error": str(exc)}), 400


@api_bp.get("/api/export-json")
def export_json():
	session = get_db_session()
	try:
		rows: List[Task] = session.execute(select(Task)).scalars().all()
		data = [
			{
				"id": t.id,
				"project_name": t.project_name,
				"task_name": t.task_name,
				"user_name": t.user_name,
				"start_date": t.start_date.isoformat(),
				"days_required": t.days_required,
				"end_date": t.end_date.isoformat(),
				"progress": t.progress,
			}
			for t in rows
		]
		return jsonify(data)
	finally:
		session.close()


def _month_key(by: str) -> Tuple:
	if by == "end":
		return (extract("year", Task.end_date), extract("month", Task.end_date))
	return (extract("year", Task.start_date), extract("month", Task.start_date))


@api_bp.get("/api/analytics/tasks/monthly-aggr")
def analytics_monthly_aggr():
	by = request.args.get("by", "start").lower()
	session = get_db_session()
	try:
		year, month = _month_key(by)
		q = (
			select(
				year.label("year"),
				month.label("month"),
				func.count(Task.id).label("task_count"),
				func.avg(Task.progress).label("avg_progress"),
			)
			.group_by(year, month)
			.order_by(year, month)
		)
		rows = session.execute(q).mappings().all()
		return jsonify([dict(r) for r in rows])
	finally:
		session.close()


@api_bp.get("/api/analytics/progress/monthly")
def analytics_progress_monthly():
	session = get_db_session()
	try:
		year = extract("year", Task.start_date)
		month = extract("month", Task.start_date)
		stats_q = (
			select(
				year.label("year"),
				month.label("month"),
				func.avg(Task.progress).label("avg_progress"),
				func.min(Task.progress).label("min_progress"),
				func.max(Task.progress).label("max_progress"),
			)
			.group_by(year, month)
		)
		stats = session.execute(stats_q).mappings().all()
		if not stats:
			return jsonify({"months": []})
		min_month = min(stats, key=lambda r: r["avg_progress"])
		max_month = max(stats, key=lambda r: r["avg_progress"])
		return jsonify({
			"months": [dict(r) for r in stats],
			"min_avg_progress_month": dict(min_month),
			"max_avg_progress_month": dict(max_month),
		})
	finally:
		session.close()


@api_bp.get("/api/analytics/tasks")
def analytics_tasks_by_user():
	user_name = request.args.get("user_name")
	if not user_name:
		return jsonify({"error": "user_name is required"}), 400

	sort_arg = request.args.get("sort", "start_date:asc")
	field, _, direction = sort_arg.partition(":")
	order_field = getattr(Task, field, Task.start_date)
	order = asc(order_field) if direction.lower() != "desc" else desc(order_field)

	session = get_db_session()
	try:
		q = select(Task).where(Task.user_name == user_name).order_by(order)
		rows = session.execute(q).scalars().all()
		data = [
			{
				"id": t.id,
				"project_name": t.project_name,
				"task_name": t.task_name,
				"user_name": t.user_name,
				"start_date": t.start_date.isoformat(),
				"days_required": t.days_required,
				"end_date": t.end_date.isoformat(),
				"progress": t.progress,
			}
			for t in rows
		]
		return jsonify(data)
	finally:
		session.close()

outside the app 

run.py

from app import create_app

app = create_app()

if __name__ == "__main__":
	app.run(debug=True)


requirements.txt

Flask==3.0.3
Flask-Cors==4.0.1
SQLAlchemy==2.0.36
psycopg2-binary==2.9.9
pandas==2.2.3
openpyxl==3.1.5
python-dotenv==1.0.1

